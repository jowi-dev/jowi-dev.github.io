<!DOCTYPE html>
<html>
<head>
  <title>Functions</title>
  <meta charset="utf-8">
</head>
<body>
  <article>
    <h1>Functions</h1>
    <div class="content">
      <h1>
Public, Private, Anonymous Functions</h1>
<h2>
Public Functions</h2>
<h3>
TypeScript</h3>
<h4>
Functional Form</h4>
<pre><code class="TypeScript">export function addOne(num : number): number {
  return num + 1;
}

// called via
addOne(1)</code></pre>
<h4>
Object-Oriented Form</h4>
<pre><code class="TypeScript">class numMutator {
  static addOne(num: number) : number {
      return num + 1;
  }
}

// called via
numMutator.addOne(1);</code></pre>
<h3>
Elixir</h3>
<h4>
Notable Differences</h4>
<p>
There are a few distinct differences between the TypeScript world and the Elixir world of functions. First and foremost the keyword differences. We use <code class="inline">def</code> to <code class="inline">define</code> a public function, and instead of braces we say <code class="inline">do/end</code> to describe the contents of the body. </p>
<p>
<code class="inline">@spec</code> is another oddity in elixir; it is our attempt at describing types. rather than cluttering a function declaration with typing, in effect we move it to the line above as a description. a <code class="inline">@spec</code> is read relatively simply as:</p>
<pre><code class="elixir">@spec $function_name($param1_type, $param2_type, ...) :: $return_type</code></pre>
<p>
Ergonomically, my biggest hurdle in the elixir world was the lack of <code class="inline">return</code> as a keyword. I <em>hated</em> it when I started, but have grown to appreciate the way it drives control flow. In elixir we return the final line from a function as its return value. In the following examples, the result of the addition operator is returned implicitly to the caller. This is a pretty big divorce from the C-style <code class="inline">if(err) return;</code> control flow used to break out of functions early, but I’ll touch on that in a future section (TODO - LINK TO CONTROL FLOW SECTION)</p>
<h4>
Standard Form</h4>
<pre><code class="Elixir">@spec addOne(integer()) :: integer()
def addOne(num) do
  num + 1
end

# called via
addOne(1)</code></pre>
<h4>
One Liner</h4>
<pre><code class="elixir">@spec addOne(integer()) :: integer()
def addOne(num), do: num + 1

# called via
addOne(1)</code></pre>
<h2>
Private Functions</h2>
<p>
I’ll save the word count in this section, as it has very minor differences from the public function section from above.</p>
<h3>
TypeScript</h3>
<h4>
Functional Form</h4>
<pre><code class="TypeScript">function addOne(num : number): number {
  return num + 1;
}

// called via
addOne(1);</code></pre>
<h4>
Object-Oriented Form</h4>
<pre><code class="TypeScript">class numMutator {
  private addOne(num: number) : number { 
      return num + 1;
  }
}

</code></pre>
<h3>
Elixir</h3>
<p>
Want a private in elixir? <code class="inline">defp</code> instead of <code class="inline">def</code>. That’s all there is to it.</p>
<h4>
Standard Form</h4>
<pre><code class="Elixir">@spec addOne(integer()) :: integer()
defp addOne(num) do
  num + 1
end

# called via
addOne(1)</code></pre>
<h4>
One Liner</h4>
<pre><code class="elixir">@spec addOne(integer()) :: integer()
defp addOne(num), do: num + 1


# Called via
addOne(1)</code></pre>
<h2>
Anonymous Functions</h2>
<p>
In TypeScript, there is a embraced love for the idea of functions as a first class citizen. something like <code class="inline">const addOne = (num) =&gt; num + 1;</code> can be seen with fairly liberal use. Elixir has a few variations of the same idea, but they are expressed (usually) at very distinct times - mostly expressed in the various standard library functions as additional logic.</p>
<h3>
TypeScript</h3>
<pre><code class="TypeScript">const addOne(num) =&gt; num + 1;

// which is then called via

addOne(1) // returns 2</code></pre>
<h3>
Elixir</h3>
<p>
Elixir has two distinct methods of creating anonymous functions, which have different advantages syntactically but little difference from an implementation perspective. Additionally, calling anonymous functions in elixir has a distinct difference from calling regular functions with the addition of a period between the variable name and the parenthesis surrounding the parameters.</p>
<pre><code class="elixir">addOne = fn num -&gt; num + 1 end

# OR

addOne = &amp;(&amp;1 + 1)


# In either case, we then call them via

addOne.(1) # Notice the `.` !</code></pre>
<h2>
Closing</h2>
<p>
Give these a try in your repl and see what you think! In the next section we’ll cover control flow TODO - LINK</p>

    </div>
  </article>
</body>
</html>
